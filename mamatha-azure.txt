21-04-2025
Cloud: The cloud is a distributed collection of servers that hosts software and infrastructure, and it is accessed over the internet.
Cloud Computing: Cloud computing refers to the on-demand availability of computing resources, such as data storage, servers, networking capabilities, and software, over the internet.
Cloud computing enables various operations such as:
    Developing new applications and services
    Storage, backup, and recovery of data
    Hosting blogs and websites
    Delivery of software on demand
Benefits of Cloud Computing :
    Cost Savings – Pay only for what you use without investing in physical hardware.
    Scalability – Instantly scale resources up or down based on demand.
    Performance – Reduced latency and improved application performance.
    Reliability – Easier and cost-effective backup and disaster recovery.
    Productivity – Reduces IT management overhead and setup time.
    Security – Offers strong protection for data and applications against threats.
Cloud Deployment Models:
    A cloud deployment model fundamentally determines where the infrastructure for your deployment exists and who owns and controls that infrastructure. It also          figures out the nature and intention of the cloud.
Public Cloud:
    In a public cloud, computing resources such as servers, storage, and applications are owned and operated by a third-party cloud service provider and delivered 
    over the internet.
Advantages of Public Cloud : Minimal Investment, No Setup Cost, No Infrastructure Management, No Maintenance, Dynamic Scalability
Disadvantages of Public Cloud :Less Secure, Low Customization, Limited Control, Compliance Issues.
Private Cloud:
    A Private Cloud is a secure, isolated cloud environment dedicated to a single organization, offering exclusive access to computing resources. It can be hosted        on- premises or by a third-party, and is managed internally or externally, providing enhanced control, security, and customization.
Key Characteristics of Private Cloud: Exclusive Use, Enhanced Security, Customization, Compliance-Friendly 
Advantages: Better Control, Data Security & Privacy, Legacy System Support, Customization  Disadvantages: Less Scalable, Costly.
Hybrid Cloud: 
    A Hybrid Cloud is a combination of both public and private clouds, allowing data and applications to be shared between them. It offers the flexibility to run         sensitive workloads in the private cloud while leveraging the scalability and cost-effectiveness of the public cloud.
Advantages of the Hybrid Cloud Model: Flexibility and Control, Cost Efficiency, Security 
Disadvantages of the Hybrid Cloud Model: Complex Management, Latency Issues.
Community Cloud:
    A Community Cloud is a cloud infrastructure shared by several organizations with similar requirements (e.g., compliance, mission, or security). It can be managed     by one or more organizations or a third party.
Advantages: Cost Effective, Enhanced Security, Resource Sharing | Disadvantages: Limited Scalability, Less Customization
Multi-Cloud:
    Multi-Cloud is a cloud strategy where an organization uses services from multiple public cloud providers (like AWS, Azure, GCP) to distribute workloads and avoid     dependency on a single vendor.
Advantages: Reduced Latency, High Availability | Disadvantages: Complex Management, Security Risks.
Cloud Computing Services:
Infrastructure as a Service (IaaS) :
    Is a cloud computing model that delivers virtualized computing resources—like servers, storage, and networking—over the internet. It eliminates the need for         organizations to own physical hardware. Infrastructure as a Service (IaaS) is a cloud computing service model that provides virtualized computing resources over      the internet. In an IaaS model, organizations access and manage fundamental IT resources—such as virtual machines, storage, networks, and operating systems—on        demand from a cloud provider. This eliminates the need for organizations to invest in and maintain their own physical IT infrastructure.
Key Characteristics of IaaS: 
    Resources as a Service, Pay-as-you-go Pricing, Scalability, Self-Service Provisioning, Virtualization, Multi-tenancy 
Benefits of IaaS: 
    Cost Reduction, Scalability and Flexibility, Faster Deployment, Increased Reliability and Availability, Focus on Core Business, Global Reach, Business Continuity and Disaster Recovery 
Challenges of IaaS: 
    Security, Compliance, Integration with Existing Systems, Dependency on Provider, Managing Costs, Limited Control, Vendor Lock-in
Common Use Cases for IaaS:
    Web Hosting, Test and Development Environments, Data Storage Backup and Recovery, High-Performance Computing (HPC), Big Data Analytics, Virtual Data Centers, Business Continuity and Disaster Recovery.
Examples of IaaS Providers: 
    AWS, Microsoft Azure, Google Cloud Platform (GCP), DigitalOcean, Linode, Rackspace, IBM Cloud, Alibaba Cloud, Oracle Cloud
Platform as a Service:
    Platform as a Service (PaaS) provides a cloud-based runtime environment where developers can build, test, deploy, and manage applications without handling the        underlying infrastructure. The platform handles hardware, OS, networking, storage, and scalability.
Key Characteristics of PaaS: 
    Complete Development and Deployment Environment, Focus on Application Development, Built-in Scalability and Availability, Support for Multiple Programming 
Benefits of PaaS: 
    Accelerated Development Cycles, Reduced Complexity, Lower Costs, Scalability and High Availability,  Improved Collaboration, Faster Time to Market, Automatic Updates and Patching 
Challenges of PaaS:
    Vendor Lock-in, Limited Control, Security Concerns, Integration with Existing Systems, Customization Limitations, Performance Issues
Common Use Cases for PaaS: 
    Web Application Development and Hosting, Mobile Application Development, API Development and Management, Data Analytics and Business Intelligence, Stream Processing, IoT Application Development, Team Collaboration and Workflow Automation |
Examples of PaaS Providers: 
    AWS Elastic Beanstalk, Google App Engine, Microsoft Azure App Service, Heroku, OpenShift, Cloud Foundry, Engine Yard, Mendix, OutSystems
Software as a Service (SaaS) :
    SaaS is also known as "On-Demand Software". It is a software distribution model in which applications are hosted by a cloud service provider and made available       to users over the internet. SaaS eliminates the need for organizations to install, maintain, or manage software locally.
Key Characteristics of SaaS: 
    Web-Based Access, Centralized Hosting, Subscription-Based Pricing, No Infrastructure Management, Automatic Updates and Patching, Scalability and Flexibility, Accessibility from Anywhere, Multi-tenancy Architecture 
Benefits of SaaS: 
    Lower Upfront Costs, Reduced IT Overhead, Faster Implementation, Automatic Updates and Maintenance, Scalability and Flexibility, Accessibility, 
Challenges of SaaS: 
    Data Security and Privacy, Vendor Lock-in, Limited Customization, Integration Issues, Dependency on Internet Connectivity, Control Over Features 
Common Use Cases for SaaS: 
    Customer Relationship Management (CRM), Enterprise Resource Planning (ERP), Email and Collaboration, Office Productivity Suites, Human Resources Management           (HRM), Content Management Systems (CMS), Project Management, Accounting Software, Marketing Automation, Video Conferencing 
Examples of SaaS Providers: 
    Salesforce, Microsoft, Google, Adobe, Zoom, Dropbox, Slack, ServiceNow, Atlassian, Oracle
XaaS (Anything as a Service):
    A broad term that refers to delivering anything as a service over the internet, including IaaS, PaaS, SaaS, and more.
Advantages:
    Scalable to changing needs, Flexible across various IT services, Cost-effective, pay-as-you-go
Disadvantages:
    Vendor dependency, Limited flexibility for unique workloads, Integration issues with legacy systems
FaaS (Function as a Service):
    A serverless model where small pieces of code (functions) run in response to events, without managing infrastructure.
Advantages:
    Highly scalable & cost-effective, No server management, Write functions in any language, Great for microservices and event-driven apps
Disadvantages:
    Cold start latency, Limited infrastructure control, Security & scalability concerns
Example Use Case: 
    Image resizing in a photo app when a file is uploaded.
Popular Providers: 
    AWS Lambda, Google Cloud Functions, Azure Functions, IBM OpenWhisk
Security Concerns in IaaS, PaaS, and SaaS
IaaS Security Risks:
IaaS exposes more of the infrastructure to users, which means managing the operating system, applications, and network security is the user's responsibility.
Common Attacks:
    Data breaches
    Denial-of-service (DoS) attacks
    Vulnerabilities in virtual machine configurations
PaaS Security Risks:
In PaaS, security is shared between the cloud provider and the customer. While the cloud provider manages the infrastructure, the customer needs to focus on securing their application and data.
Common Attacks:
    Misconfiguration vulnerabilities
    Insufficient authentication and authorization
    API security risks
SaaS Security Risks:
SaaS models have the least amount of user control, as the application is fully managed by the provider. However, there are still potential security concerns related to user data and access management.
Common Attacks:
    Data leakage
    Account hijacking
    Service interruptions due to cyberattacks
Functional Requirements (FR):
Functional requirements specify what a system should do. They describe the specific behaviors, actions, or functions the system must have to meet the needs of its users. Essentially, functional requirements define the capabilities of the system.
Characteristics of Functional Requirements:
    Focus on specific actions or operations of the system.
    Can be expressed as user stories or use cases.
    Directly related to the system's core functionality.
Non-Functional Requirements (NFR):
Non-functional requirements specify how a system performs its functions. They define the quality attributes and operational aspects of the system, such as its performance, scalability, security, and availability. These requirements help ensure the system works effectively and meets the users' expectations in terms of system qualities.
Examples of Non-Functional Requirements:
    Performance: The system must handle 1000 concurrent users without degradation in speed.
    Scalability: The system must be able to scale horizontally to support a growing number of users.
    Availability: The system must have 99.9% uptime.
    Security: The system must encrypt sensitive user data using AES-256 encryption.
    Usability: The system’s user interface must be simple and intuitive for new users.
Compile-Time Caching:
    Compile-time caching stores pre-compiled assets or intermediate build results (like Java bytecode, bundled JavaScript, or optimized images) during the build process.
Benefits:
    Faster builds.
    Efficient resource usage.
    Reduces build time across environments and teams.
Runtime Caching:
    Runtime caching refers to storing data during application execution, so it doesn't need to be fetched or recalculated repeatedly.
Benefits:
    Better performance.
    Reduced server load.
    Improved scalability.
Alpine Linux:
    Alpine Linux is a security-oriented, lightweight Linux distribution designed for power users who need performance and simplicity. It is musl libc- and BusyBox-based, making it extremely small and efficient.
Common Use Cases:
    Microservices in containers (e.g., Go, Node.js, Python apps).
    CI/CD tools and pipelines.
    Serverless functions (custom containers).
    Lightweight VMs in edge computing.
Feature Benefit
    Small Image Size : Typically ~5 MB, reducing image size and speeding up pulls.
    Minimal Packages : Only the essentials, reducing attack surface.
    Security Focused : Hardened kernel, PaX, grsecurity patches (historically).
    Customizability : Easy to extend and build from.
NSG(Network Security Group):
    NSG (Network Security Group) is a security feature in Microsoft Azure that acts as a virtual firewall to control inbound and outbound traffic to Azure resources      at the network level.
    NSGs allow or deny traffic based on rules like source/destination IP addresses, ports, and protocols.
Where NSGs are Applied: NSGs can be associated with:
    Network Interfaces (NICs) – for controlling traffic to individual virtual machines.
    Subnets – for controlling traffic to all resources in the subnet.
NSG Rule Key Components: Name, Priority, Direction, Access, Protocol, Source, Source Port Range, Destination, Destination Port Range.
Best Practices for NSGs: Least Privilege, Subnet-Level NSGs, NIC-Level NSGs, Avoid Conflicting Rules, Log and Monitor, Use Service Tags, Use Application Security Groups (ASGs).
pplication Security Groups (ASGs): Group VMs logically and apply rules to ASGs instead of IPs.

Types of Kubernetes Scaling :
    Scaling in Kubernetes ensures your application runs smoothly under varying workloads by adjusting pods or nodes automatically or manually.
There are three main types of scaling:
1. Horizontal Pod Autoscaler (HPA)
2. Vertical Pod Autoscaler (VPA)
3. Cluster Autoscaler
Horizontal Pod Autoscaler (HPA):
What it does:
    Automatically increases or decreases the number of pod replicas based on resource utilization or custom metrics.
Metrics Used:
    CPU utilization (default)
    Memory (via custom metrics adapter)
    Custom metrics (e.g., queue length, request rate)
Components Required:
    Metrics Server (must be installed in the cluster)
    Deployment or StatefulSet with resources.requests.cpu and resources.limits.cpu defined
How it works:
    HPA controller checks metrics every 15 seconds (configurable).
    Compares current usage with the target average utilization.
    Adjusts the number of replicas in the deployment.
Vertical Pod Autoscaler (VPA):
What it does:
    Automatically adjusts the CPU and memory requests/limits for a pod.
Why Use It:
    When app performance depends more on pod capacity per instance rather than number of pods.
    Ideal for batch jobs, stateful apps, or low request-volume services.
How it works:
    Monitors usage patterns over time
    Recommends or applies updated resource requests
    Can evict and restart pods with the new values
Cluster Autoscaler:
What it does:
    Automatically adds/removes nodes to/from the Kubernetes cluster based on unschedulable pods.
Why Use It:
    Helps save costs in cloud environments (e.g., AWS, GCP, Azure) by adjusting the size of the cluster dynamically.
Requirements:
    Must be deployed separately in the cluster
    Needs cloud provider support (e.g., auto-scaling groups on AWS EC2)
How it works:
    Periodically checks if any pods are in a Pending state due to lack of resources.
    If yes, adds more nodes (up to a max limit).
    If nodes are underutilized for a long time, it scales them down.
Bastion Host:
Bastion host is a specialized server designed as a secure gateway, providing controlled access to internal, private networks from external networks like the internet.
A Bastion Host is a server that acts as a gateway between a private network and the public internet. It is used to securely access servers in a private network (e.g., in a VNet). Bastion Hosts are configured with limited access and hardened security to minimize risk.
Key Characteristics of a Bastion Host: 
        Publicly reachable via SSH/RDP, secures access to internal resources without public IPs, protected by firewall/NACL/NSG, MFA, and hardened OS settings.

22-04-2025

VNet (Azure):
        A VNet in Azure is a private network that allows communication between resources such as VMs, databases, and storage within the cloud.
        A VNet (Azure) or VPC (AWS) is a logically isolated network in the cloud.
        It allows you to define your own IP address range, subnets, route tables, and security rules.
Key Features:
        Custom CIDR blocks (e.g., 10.0.0.0/16)
        Subnets to divide and organize resources
        Security control via NSGs (Azure) or NACLs/Security Groups (AWS)
        Internet Gateway, NAT Gateways, VPNs.
VNet/VPC Peering:
        Allows virtual networks to connect to each other and share resources. It is typically used when resources are distributed across multiple VNets/VPCs.
        VNet Peering is the process of connecting two virtual networks so they can communicate privately, just like one network.
        It lets resources in different VNets talk to each other (like a VM in VNet A accessing a database in VNet B).
        The communication is secure, low-latency, and doesn’t go over the public internet.
        It’s like building a private tunnel between two highways (VNets).
Benefits of VNet/VPC Peering:
        Private traffic (no exposure to internet).
        Low latency and high bandwidth.
        No need for VPNs between VNets.
        Easy to set up and manage.
A Virtual Machine (VM):
    Is a software-based emulation of a physical computer. It runs an operating system and applications just like a real computer, but it does so inside a host system using virtualization technology.
Key Points:
        Isolated Environment: Each VM operates independently, with its own OS, resources (CPU, memory, storage), and applications.
        Runs on a Hypervisor: A hypervisor (like VMware, Hyper-V, or KVM) manages and runs multiple VMs on a single physical host.
        Used For: Development, testing, running legacy apps, hosting services, and scaling cloud environments.
        Popular in Cloud: In platforms like Azure or AWS, VMs are on-demand and can be scaled based on need.
Express Gateways :
Express Gateway is an open-source API Gateway built entirely on top of Node.js and the popular Express.js framework. It’s designed to manage microservices APIs, offering features like authentication, rate-limiting, logging, and monitoring — all easily configured using a simple YAML file.
NAT Gateway: 
A NAT Gateway (Network Address Translation Gateway) is a resource in Azure that enables outbound internet access for resources in a private subnet—without exposing them to incoming traffic from the internet.
What Does It Do :
        Allows virtual machines, containers, or other services in private subnets to make outbound connections to the internet (downloading updates, calling APIs).
        Prevents inbound connections, ensuring resources stay secure and private.
VM Scale Sets (VMSS) :
A Virtual Machine Scale Set (VMSS) is an Azure compute service that lets you deploy and manage a group of identical, load-balanced virtual machines.
VM Scale Sets help you automatically scale out (add more VMs) or scale in (remove VMs) based on demand.
How VMSS Works:
1. You define a scale set configuration:
        o VM image (Ubuntu, Windows Server, etc.)
        o VM size (e.g., Standard_B2s)
        o Autoscaling rules (CPU > 75%, scale out; CPU < 30%, scale in)      
        o Network settings (subnet, NSG, load balancer)
2. Azure creates the initial number of VMs (e.g., 2).
3. Traffic is routed through a load balancer to the VMs.
4. When demand increases, Azure adds more VMs to handle traffic.
5. When demand drops, Azure removes unnecessary VMs, saving cost.
When to Use VM Scale Sets
Use cases:
        · High-traffic web applications
        · API backends
        · Microservices
        · Stateless services
        · Batch processing
Not ideal for:
        · Stateful apps without external storage
        · Apps needing persistent local storage
Fault Domain:
A Fault Domain is a logical grouping of hardware resources (like power supply, network, and physical servers) within a data center that shares a single point of failure.
Purpose:
It protects your VMs from hardware failures. When you deploy multiple VMs, Azure distributes them across fault domains to avoid all your VMs being affected by a single failure.
Example:
If you deploy 3 VMs and specify 2 fault domains:
        · VM1 goes to Fault Domain 1
        · VM2 goes to Fault Domain 2
        · VM3 goes back to Fault Domain 1
So, if Fault Domain 1 fails (e.g., power outage), only VM1 and VM3 are affected — not all VMs.
What is an Update Domain:
An Update Domain is a logical group used to separate VMs for software or OS updates to ensure availability during maintenance.
Purpose:
Azure uses Update Domains to roll out updates one group at a time, not all at once, reducing downtime.
Example:
If you have 5 VMs and 3 update domains:
        · VM1 → Update Domain 1
        · VM2 → Update Domain 2
        · VM3 → Update Domain 3
        · VM4 → Update Domain 1
        · VM5 → Update Domain 2
Azure updates one domain at a time, waits for success, then proceeds. So, your app stays online during updates.
SSD (Solid State Drive):
        SSD is a type of high-speed storage that uses flash memory. In cloud computing, SSDs are used for performance-intensive applications.
HDD (Hard Disk Drive): 
        HDDs are mechanical drives that store data magnetically. They're slower than SSDs but much cheaper.
Feature       SSD                 HDD
Speed         Very fast         Slower
Cost            High             Low
Use Case       Databases      VMs Backups, cold storage
Ephemeral Storage: 
        Ephemeral storage is temporary disk space attached to a virtual machine. It is non-persistent — meaning the data is lost when the VM is stopped or deallocated.

23-04-2025

What is a Subnet:
A subnet (subnetwork) is a smaller, logical section of a larger network (like a VPC in AWS or VNet in Azure). It helps divide a big network into smaller, manageable chunks.
Why Do We Use Subnets:
        · To organize and isolate resources (e.g., frontend vs backend).
        · To apply security rules (e.g., NSGs or firewalls) on specific subnets.
        · To control traffic flow and improve performance.
What is Subnetworking (Subnetting) :
Subnetworking, also known as subnetting, is the practice of dividing a larger IP network into smaller, manageable subnets. This allows better control of traffic flow, more efficient IP address usage, and improved network security
Benefits of Subnetting
        1. Improved Security – Restrict access between subnets with firewalls or NSGs.
        2. Better Performance – Reduced broadcast domains = faster network.
        3. Efficient IP Usage – No waste of IPs; assign based on exact need.
        4. Scalability – Makes large networks easier to manage and expand
Azure Use Case: Subnets are part of a VNet (Virtual Network). Subnetwork Example:
to create networks we need cidr 
we have three 
10.0.0.0/24->10.0.0.0-----10.0.0.255 32-24=8 2^8=256 
10.0.0.0/24 ---> 10.0.0.0--- 10.0.0.255
network--        1    2    4     8     16     32     64    128      256
host--           256  128  64    32     16    8      4      2        1
subnet mask--    /24  /25  /26   /27   /28    /29   /30     /31      /32

we are dividing these into 4 ways: 10.0.0.0
TEAMS     ip range                      newtwork id              boardcast id                   cidr

A---  10.0.0.1---10.0.0.62               10.0.0.0                 10.0.0.63                   10.0.0.0/26      

B---  10.0.0.65---10.0.0.126             10.0.0.64                10.0.0.127                  10.0.0.64/26 

C---  10.0.0.129---10.0.0.190            10.0.0.128               10.0.0.191                  10.0.0.128/26 

Azure Web App :
Azure Web App (part of Azure App Service) is a PaaS (Platform as a Service) offering that allows developers to build and host web apps, APIs, and mobile backends in a fully managed environment. 
It takes care of infrastructure management, such as server maintenance, patching, load balancing, scaling, and security — so we can focus on writing code.
Key Features of Azure Web App: Multiple Language Support, Built-in CI/CD Integration, Scaling and Load Balancing, Global Availability, Custom Domains & SSL, Security & Authentication, Monitoring & Diagnostics, Backup and Restore, Deployment Slots.
Use Cases:
        · Hosting dynamic websites or web applications
        · Running backend APIs for mobile or web apps
        · Creating portals or dashboards
        · Integrating with Logic Apps, Functions, and databases
Benefits :
        · No infrastructure management
        · Quick deployments
        · Highly scalable
        · Cost-effective (pay-as-you-go model)
        · Enterprise-grade security

Azure Subscription:
An Azure Subscription is essentially a logical container for your Azure resources. It is the boundary within which Azure resources (such as virtual machines, databases, web apps, etc.) are created and managed. A subscription allows users to manage and organize their resources based on different factors such as project, department, or environment (production, development, etc.).
Azure Resource Groups:
An Azure Resource Group is a container that holds related Azure resources. Resources within the same resource group share a lifecycle, meaning you can manage, update, and delete them together.
Resource groups are useful for organizing and managing your Azure resources in a logical, structured way.
Key Points about Azure Resource Groups:
        · Resource Organization
        · Management and Deployment
        · Access Control
        · Resource Lifecycle
        · Geographical Location
        · Tagging

LAB: Virtual Machine Setup and Network Configuration
Step 1: Creating a New User in Microsoft Entra ID
Microsoft Entra ID (formerly Azure Active Directory) allows you to manage identities and access in Azure. Creating a user is essential for assigning roles and securing access.
Step-by-Step Guide to Create a New User
1. Sign in to Azure Portal
        •	Go to https://portal.azure.com
        •	Sign in with your administrator credentials.
2. Navigate to Microsoft Entra ID
        •	In the left-hand menu or search bar, type “Microsoft Entra ID” or “Azure Active Directory”.
        •	Click on Microsoft Entra ID to open the directory.
3. Go to Users Section
        •	In the Microsoft Entra ID pane, click on “Users” from the left sidebar.
        •	Then click on “+ New user” at the top.
4. Choose User Type
        •	Select “Create new user” (default).
        •	You can also choose to invite an external user if needed (for B2B collaboration).
5. Fill in User Details
        •	User name: Enter a unique username (e.g., devuser@yourdomain.onmicrosoft.com)
        •	Name: Enter the full name of the user.
        •	Optionally, you can add additional details such as:
                    o	Job Title
                    o	Department
                    o	Usage location
6. Set Password
        •	Azure will auto-generate a temporary password.
        •	You can also set a custom password.
        •	Make sure to note down the password, as the user will be prompted to change it at first login.
7. Assign Groups or Roles (Optional)
        •	You can assign the user to specific groups or roles:
            o	Example: Assign as Contributor, Reader, or Virtual Machine Operator.
        •	To assign roles:
                o	Click on “Roles” > “+ Add assignment” > choose a role.
8. Review and Create
        •	Review all entered information.
        •	Click “Create”.
Result
The user is now created and can:
        •	Log in via the Azure Portal
        •	Access only the assigned resources
        •	Be used for managing permissions on virtual machines, networks, storage, etc
--------------------------------------------------------------------------------------------------
Task : Creating the Virtual Network and Virtual Machines
Virtual Network (VNet)
        •	Create a Virtual Network to logically group and connect all virtual machines (VMs).
        •	This allows communication between VMs in the same VNet.
Virtual Machines
        •	Create three VMs:
            o	Frontend VM (Public)
            o	Backend VM (Intermediate)
            o	Private VM (Internal-only)
        •	Assign each VM to the same virtual network but place them in appropriate subnets (e.g., public, private).
Network Security Groups (NSGs)
Creation
        •	Create two NSGs:
            o	Public NSG (for Frontend and Backend)
            o	Private NSG (for Private VM)
Association and Disassociation
        •	Stop each VM to safely change its NIC (Network Interface Card) settings.
        •	Disassociate the NICs from default NSGs if any.
        •	Re-associate the correct NSG:
            o	Public NSG → Frontend and Backend
            o	Private NSG → Private VM
Configuring NSG Rules
Private NSG – Inbound Rules
        •	Priority 120 → Deny All traffic (to ensure security).
        •	Priority 110 → Allow SSH or specific internal traffic (to allow internal VM communication).
Public NSG – Inbound Rules
        •	Priority 105 → Allow SSH (port 22) to access the Frontend VM from your local system.
Key Insertion and SSH Connections
Step-by-Step SSH Access
1.	From Local to Frontend:
        o	Use SSH key to connect to the Frontend VM from your local machine:
            -	ssh -i keyname.pem username@frontend-ip
2.	Copy Key from Frontend to Backend:
        o	Use SCP to copy the SSH key:
            -	scp -i keyname.pem keyname.pem username@backend-ip:/home/username/
        o	Then SSH into the Backend from the Frontend:
            -	ssh -i keyname.pem username@backend-ip
3.	From Backend to Private VM:
        o	Use SSH again (use the Private VM’s private IP if in same VNet):
            -	ssh -i keyname.pem username@private-ip
Note: If VMs are in the same VNet, you don’t need a public IP to SSH internally.

Microsoft Entra ID (Formerly Azure Active Directory)
Microsoft Entra ID (formerly Azure Active Directory, or Azure AD) is a cloud-based identity and access management service. It helps organizations securely manage and control access to resources.
Key Features:
        · Identity Management: Manages user identities and access permissions.
        · Single Sign-On (SSO): Users can access multiple applications with one login.
        · Multi-Factor Authentication (MFA): Adds an extra layer of security.
        · Conditional Access: Restricts or allows access to applications based on user conditions (location, device, etc.).
        · Integration: Integrates with various third-party applications and services.
Use Cases:
        · Providing secure access to cloud and on-premises resources.
        · Managing employee and contractor access to enterprise applications.
        · Securing APIs and services in the cloud.
Azure App Services
Azure App Services is a fully managed platform for building, deploying, and scaling web apps, mobile backends, and APIs.
Key Features:
        · Auto-Scaling: Automatically scales web apps based on demand.
        · Integration: Supports integration with databases, caching, and other Azure services.
        · Multi-language Support: Supports .NET, Node.js, Python, Java, and more.
        · Security Features: Provides built-in authentication, authorization, and SSL certificates.
Use Cases:
        · Hosting web applications (e-commerce sites, content management systems).
        · Running REST APIs for mobile or web applications.
        · Hosting serverless backends.
Azure Storage Accounts
Azure Storage Accounts provide scalable, durable, and secure cloud storage for various types of data. It supports data such as blobs, files, queues, and tables.
Key Features:
        · Blob Storage: For storing large amounts of unstructured data, like images, videos, backups.
        · File Storage: Offers shared storage for legacy applications.
        · Queue and Table Storage: For message queues and NoSQL-like database solutions.
        · Durability and Availability: Multiple replication options to ensure data durability and availability.
Use Cases:
        · Storing application data, backups, and media files.
        · Providing file share services to on-premises applications.
        · Storing large datasets for Big Data and analytics.
Azure SQL Databases
Azure SQL Database is a fully managed relational database service based on SQL Server. It offers high availability, automatic scaling, and built-in security.
Key Features:
        · Automated Backups: SQL Database automatically handles backups and restores.
        · Scalable Performance: Can scale resources dynamically based on workload demands.
        · Security: Includes built-in encryption and firewall protection.
        · High Availability: Built-in features like auto-failover groups for high availability.
Use Cases:
        · Hosting applications that require a relational database.
        · Storing business-critical transactional data.
        · Running analytics on structured data.
Cost Management in Azure
Azure Cost Management is a tool to monitor and control your Azure spending. It provides insights into where and how costs are incurred, and helps you optimize your spending.
Key Features:
        · Cost Analysis: Helps visualize and analyze costs by resource, resource group, subscription, etc.
        · Budgets: Set up budgets for different teams, departments, or projects to avoid overspending.
        · Cost Recommendations: Provides insights on how to optimize costs, such as resizing underused resources.
        · Forecasting: Predict future costs based on historical data.
        · Alerts: Set up cost alerts to notify you when spending approaches a defined limit.
Use Cases:
        · Monitoring Azure resource usage and expenditures.
        · Optimizing cloud resources to reduce unnecessary costs.
        · Setting and tracking budgets for departments or project.
Azure Regions:
    An Azure Region is a geographic area that contains at least one (usually multiple) data centers located nearby each other.
Purpose:
    Regions allow users to deploy applications closer to their users for better performance and compliance with data residency laws.
Examples of Azure Regions:
    East US, West Europe, Southeast Asia, Central India
Key Points:
    Each region is independent (except for paired regions used for disaster recovery).
    Data residency — Some regions are set up to meet local government regulations about where data must reside.
    Latency and redundancy — Users choose regions based on proximity and fault tolerance needs.

Azure Availability Zones
    Availability Zones are physically separate data centers within the same Azure Region.
    Each zone has independent power, cooling, and networking.
Purpose:
    They protect applications and data from data center-level failures (e.g., power outage, natural disaster).
Structure:
    A region with Availability Zones will typically have at least three zones.
    Azure replicates services across zones if you configure them for zone redundancy.
Use Cases:
    Deploying VMs across zones for high availability.
    Hosting critical databases with synchronous replication across zones.
    Ensuring minimal downtime even if an entire data center goes offline.
Important Note:
    Not all regions support Availability Zones — only major regions do (e.g., East US 2, West Europe, Southeast Asia).

Azure Availability Sets
    An Availability Set is a logical grouping of Virtual Machines (VMs) within a single data center (inside a region).
Purpose:
    It ensures that VMs are distributed across multiple Fault Domains and Update Domains, protecting against hardware failures and maintenance events.
Key Concepts:
Fault Domain:
    Grouping of hardware that shares the same power source and network switch. If a fault domain fails (e.g., power outage), only VMs in that domain are affected.
Update Domain:
    Grouping of VMs that can be updated together. Azure updates only one update domain at a time to minimize downtime.
Example:
    If you create 5 VMs in an availability set configured with 2 fault domains and 5 update domains:
    VMs will be spread across different hardware racks (fault domains).
    During updates, Azure ensures that only one update domain (and therefore a subset of VMs) is rebooted at a time.
Best for:
    Traditional, non-distributed applications that require VM redundancy within a single region.
    Cost-effective high availability without zone-level resilience.



24-04-2025
Azure Tenants: 
  An Azure Tenant is a dedicated, isolated instance of Azure Active Directory (Azure AD) assigned to an organization when it signs up for Azure, Microsoft 365, or other Microsoft services.
  It manages users, groups, devices, policies, and apps.
  Tenant = Identity boundary (Who can log in, what they can access).
  Identity services used by Azure and Microsoft services for authentication and authorization.
Features of Azure Tenants (Short)
  Isolation: Every tenant is securely separated from others.
  Authentication and Identity Management: Manages users, groups, apps, MFA, SSO.
  Multi-Subscription Support: Multiple Azure subscriptions under one tenant.
  Conditional Access: Apply security rules based on conditions.
  RBAC: Fine-grained access control to Azure resources.
Benefits of Azure Tenants (Short)
  Security and Isolation: Ensures data privacy.
  Centralized Management: Single place for managing identities and policies.
  Single Sign-On: One login for multiple services.
  Resource Management: Organize resources easily with multiple subscriptions.
  Collaboration: Work securely with external users.
  Scalability: Easily adjust to business growth.
  Compliance: Helps meet security and regulatory requirements.
Data Centers:A data center is a physical facility used by organizations to house their critical IT systems and infrastructure, including servers, storage devices, networking equipment, and software applications. These centers ensure that business operations run smoothly by providing the computing resources necessary to handle a vast amount of data processing, storage, and management.
Key Components of a Data Center:
  Servers: High-performance computers responsible for processing and storing data.
  Storage Devices: Hard drives, SSDs, or arrays to store large volumes of data.
  Networking Equipment: Switches, routers, and firewalls that connect servers and manage data traffic.
  Cooling Systems: Air conditioning or liquid cooling systems to prevent equipment overheating.
  Power Supply: Backup generators, batteries, and redundant power systems to ensure uninterrupted operations.
  Security: Physical and cybersecurity measures to protect both the hardware and the data within the facility.
Types of Data Centers:
  Enterprise Data Centers: Built and operated by individual companies for their own use.
  Colocation Data Centers: A third-party facility where companies rent space and resources.
  Cloud Data Centers: Managed by cloud service providers like AWS, Microsoft Azure, and Google Cloud. 
Benefits of Data Centers:
  Scalability
  Security
  Data Redundancy
  Compliance
  Cost Efficiency
Key Considerations When Choosing a Data Center:
  Location
  Security
  Network Connectivity
  Redundancy and Backup
  Energy Efficiency
Azure Regional Pairs:
  Azure Regional Pairs refer to the pairing of two Azure data centers located within the same geographic region or area, usually within 300 miles of each other. Each Azure region is paired with another for the purpose of providing high availability, disaster recovery, and data residency.
  Pairing ensures that if one data center or region faces an outage, the services in the other paired region can continue to operate with minimal disruption.
Key Features of Azure Regional Pairs:
    High Availability
    Disaster Recovery
    Data Residency and Compliance
    Synchronous Data Replication
    Automatic Failover
    Service Boundaries
Examples of Azure Regional Pairs:  East US & West US, North Europe & West Europe, and Central India & South India.
Benefits of Azure Regional Pairs:
    Reliability: Redundancy through distribution of workloads between physically separate locations.
    Business Continuity: Enables service failover during unplanned disruptions.
    Cost Efficiency: Disaster recovery can be optimized without separate infrastructure investments.
    Reduced Latency: Paired regions within 300 miles offer low-latency data transfer.
    Compliance & Residency: Helps meet legal/regulatory standards for data storage.
Choosing a Regional Pair:
    Compliance Requirements: Ensure data storage meets regulatory requirements in specific regions.
    Proximity to End-Users: Choose a region closer to your target audience to reduce latency.
    Cost Implications: Balance costs associated with inter-region data transfer and redundancy.
Azure Global Network :
    Is a high-performance, low-latency, and highly resilient network that connects Azure’s global data centers, ensuring seamless communication across regions. It provides the foundation for Azure’s services and enables global applications to scale efficiently, with enhanced performance, security, and availability.
Key Features of Azure Global Network:
    Global Connectivity: Fast, secure data transfer across 60+ regions.
    Private Connectivity: Low-latency, private connections bypassing the public internet.
    ExpressRoute: Dedicated private connections for better security and performance.
    Content Delivery Network (CDN): Low-latency content delivery with global caching.
    Traffic Routing: Optimized routing using public and private networks.
    Security: Multi-layered security with DDoS protection.
Benefits of Azure Global Network:
    Improved Performance: Optimized for global applications.
    Reliability: High availability and fault tolerance.
    Scalability: Scales applications globally without compromising speed.
    Cost Efficiency: Reduced latency and operational costs.
    Enhanced Security: Protection against network threats.
Edge Locations in Azure?
In Azure, Edge Locations are physical data centers in Azure's Content Delivery Network (CDN). They are strategically placed across various geographical regions to improve performance by caching and delivering content closer to users.
Purpose of Edge Locations:
Edge locations optimize the delivery of content, reduce latency, and improve the overall user experience by caching static content like images, videos, and other web assets.
Role in Azure CDN:
Edge locations serve as key components of Azure's CDN, allowing for content caching and quick retrieval from the nearest location to the end user, enhancing performance for global applications.
Benefits of Edge Locations:
    Low Latency: Content is delivered from the nearest edge location, reducing load times.
    High Availability: Edge locations help improve content availability by distributing it globally.
    Cost Efficiency: Reduces the load on origin servers and reduces bandwidth costs.
Use Cases for Edge Locations:
    Video Streaming: Distributing high-quality video content with minimal buffering.
    Web Acceleration: Speeding up the delivery of websites and applications to users globally.
    Global Content Delivery: Serving static files and assets to users around the world without overloading the central server.
Key Features of Edge Locations:
    Caching: Temporary storage of frequently accessed content for faster retrieval.
    Intelligent Routing: Azure Traffic Manager and Azure Front Door route requests to the nearest edge location based on user proximity.
    Security: Protection through features like DDoS protection and Web Application Firewall (WAF) at edge locations.
Azure Resource Group:
    Is a logical container used to organize and manage related Azure resources. It allows you to group resources that share the same lifecycle, such as virtual machines, databases, networking components, and storage accounts.
Characteristics of Azure Resource Group:
    Logical Container
    Unified Management
    Location of Resources
    Lifecycle
    Tagging
Benefits of Azure Resource Groups:
    Simplified Resource Management
    Access Control
    Resource Organization
    Cost Management
    Template Support
    Security
How to Manage Resource Groups:
    Azure Portal:
        -Create and manage
        -Assign Permissions
        -Monitor resources
Azure Resource Manager (ARM):
    Is the deployment and management service for Azure. It provides a consistent management layer that allows you to create, update, and delete resources in your Azure account in a structured, automated, and secure way.
Key Features of Azure Resource Manager (ARM)
    Unified Management Layer
    Declarative Templates (ARM Templates)
    Role-Based Access Control (RBAC)
    Resource Group Management
    Tagging Support
    Dependency Management
    Consistent Deployment
Benefits of Azure Resource Manager
    Automation
    Consistency
    Security
    Monitoring
    Tagging & Cost Control
Azure Bicep
    Azure Bicep is a Domain Specific Language (DSL) for deploying Azure resources. It is a more concise, readable alternative to ARM (Azure Resource Manager) templates, designed to simplify the process of writing and managing Infrastructure as Code (IaC) in Azure.
Features of Bicep :
    Readable Syntax: YAML-like clarity, but strongly typed.
    Modular: Use module keyword to reuse code.
    Built-in Type Safety and IntelliSense.
    Automatic Dependency Handling
    Source Control Friendly
    Tooling: Great support in Visual Studio Code
    Azure Subscriptions – Complete Guide
Benefits of Azure Bicep:
    Increased Productivity: Simplified syntax allows faster infrastructure code development.
    Enhanced Readability: Bicep's concise syntax improves code clarity and maintenance.
    Native Integration: Seamlessly integrates with Azure’s deployment tools and services.
    Improved Code Quality: Linting, strong typing, and modules help improve code quality.
    Compatibility: Generates ARM templates compatible with existing Azure tooling.
How to Use Azure Bicep:
    Install Bicep CLI: Install the Bicep CLI tool via Azure CLI or from GitHub.
    Write a Bicep File: Create a .bicep file to define infrastructure resources.
    Compile to ARM Template: Use the Bicep CLI to convert the .bicep file to an ARM template.
    Deploy with Azure CLI: Deploy the ARM template using Azure CLI, PowerShell, or the Azure Portal.
Azure Subscriptions: An Azure subscription is an agreement with Microsoft to use Azure services, which acts as a container for managing and organizing resources, billing, and access control. It provides a logical boundary for Azure services, and each subscription has its own billing, resource limits, and access permissions.
Why Azure Subscriptions Are Necessary: Azure subscriptions are necessary to organize, manage, and allocate resources effectively, ensuring proper billing, access control, and resource management. They also provide a structure for applying quotas and limits to prevent overuse of resources.
Types of Azure Subscriptions: 
    Pay-As-You-Go
    Enterprise Agreement (EA)
    Cloud Solution Provider (CSP)
    Microsoft Customer Agreement (MCA)
    Dev/Test Subscription
    Visual Studio Subscription
Managing Azure Subscriptions: 
    Azure Portal
    Azure CLI/PowerShell
    Azure Cost Management
    Role-Based Access Control (RBAC)
    Subscription Management API
Azure Account:
    An Azure account is the basic entity used to access Azure services and manage resources. It is associated with a user identity and provides access to various         Azure services, subscriptions, and billing.
    It allows you to manage resources, monitor usage, set up billing, and access services like VMs, storage, networking, databases, and more.
Key Components of an Azure Account:
    Microsoft Account or Work/School Account
      - Your identity to sign in (like yourname@outlook.com or yourorg.com account).
    Azure Subscription
      - A container for billing, services, and resource management.
      - You can have multiple subscriptions under one Azure account.
      -	Each subscription has resource quotas, billing details, and role-based access control (RBAC).
    Directory (Microsoft Entra ID)
        - Azure uses Microsoft Entra ID (formerly Azure AD) to manage users and access across subscriptions and resources.
Azure Billing:
    Azure billing refers to the process of charging for the usage of Azure services based on consumption. It includes tools to manage subscription costs, track           usage, and generate invoices for Azure services consumed.
Important Azure Billing Tools:
      Cost Analysis: Visualizes where you’re spending money (by service, region, resource).
      Budgets and Alerts: Set spending limits and get alerts when you approach them.
      Invoices & Usage Reports: Download detailed usage and invoice data.
Azure Pricing Calculator:
    The Azure Pricing Calculator is a web-based tool that helps estimate the cost of Azure services based on different configurations and usage patterns. It allows       users to select specific services, set usage parameters, and calculate projected costs.
Key Features of Azure Pricing Calculator:
    Comprehensive Service Selection
    Cost Estimation and Comparison
    Customizable Configurations
    Interactive Pricing
    Export Pricing Estimate
Benefits of Using Azure Pricing Calculator:
    Cost Estimation Accuracy
    Budgeting and Financial Planning
    Scenario Testing
    Optimizing Resource Usage
    Managing Multiple Azure Subscriptions
How to Use Azure Pricing Calculator:
    Selecting Azure Services
    Configuring Resources
    Viewing Pricing Breakdown
    Saving and Sharing Estimates
How to Access the Azure Pricing Calculator:
    Via Azure Portal
    Using Direct URL
Example Use:
If we want to estimate the cost of running a Virtual Machine:
    1.	Go to the Azure Pricing Calculator
    2.	Select Virtual Machines
    3.	Choose:
        o	Region (e.g., Central India)
        o	OS (Linux/Windows)
        o	VM Size (e.g., B1s)
        o	Hours per month
        o	Storage type and amount
    4.	It shows the estimated monthly cost\


LAB: VNET PEERING:
Step 1: Created Two Virtual Networks (VNets)
    -	az network vnet create --resource-group mamatha-rg --name mamatha-vnet-1 --address-prefixes 10.11.0.0/16
    -	az network vnet create --resource-group mamatha-rg --name mamatha-vnet-2 --address-prefixes 10.12.0.0/16
Step 2: Created Subnets in Each VNet
    -	az network vnet subnet create --resource-group mamatha-rg --vnet-name mamatha-vnet-1 --name mamatha-sub1 --address-prefix 10.11.0.0/24
    -	az network vnet subnet create --resource-group mamatha-rg --vnet-name mamatha-vnet-2 --name mamatha-sub2 --address-prefix 10.12.0.0/24
Step 3: Created Two VM’s 
    - az vm create --resource-group mamatha-rg  --name mamatha-vm-1 --location eastus --image "Ubuntu2204" --size Standard_B1s --vnet-name mamatha-vnet-1 --subnet        mamatha-sub1 --admin-username mamatha --admin-password 'mamathaeudulakanti@24'
    - az vm create --resource-group mamatha-rg --name mamatha-vm-2 --location eastus --image "Ubuntu2204" --size Standard_B1s --vnet-name mamatha-vnet-2 --subnet         mamatha-sub2 --admin-username mamatha-1--admin-password 'mamathaeudulakanti@24'
Step 4: Two Networks Security Groups will be created for two VM’s.
Step 5: For both NSG’s allow ICMP protocol for the purpose of communication .
Step 6: We will create peering for the vnet1-vnet2 and vnet2-vnet 1
    - az network vnet peering create --name VNet-1-to-VNet-2 --resource-group mamatha-rg --vnet-name mamatha-vnet-1 --remote-vnet mamatha-vnet-2 --allow-vnet-access
    - az network vnet peering create --name VNet-2-to-VNet-1 --resource-group mamatha-rg --vnet-name mamatha-vnet-2 --remote-vnet mamatha-vnet-1 --allow-vnet-access
Step 7 : To check whether peering has been done or not :
From Vm1: ping private ip of Vm2
    -	ping 10.12.0.4
In VM2: ping@private ip of Vm1
    -	ping 10.11.0.4


Task: Create a New User in Azure (Entra ID)
Step 1:
    - Go to Microsoft Entra ID (formerly Azure AD)
    - Click on “+ Add” → Select “User” → Choose “Create new user”
Step 2:
    Fill in all required details:
    •	User name
    •	Name
    •	Password settings (Auto-generated or custom)
Step 3:
    Optionally assign user to a group (e.g., DevOpsTeam, Admins, Developers)
Step 4:
    Click “Review + Create”
    Then click “Create” to finalize

25-04-2025
Eventual Consistency:
Eventual Consistency is a consistency model used in distributed systems, where the system guarantees that, in the absence of further updates, all replicas of the data will eventually converge to the same value.
It is widely used in highly available, distributed databases and cloud systems where immediate consistency is not required.
Key Characteristics: Asynchronous Replication, Temporary Inconsistency, Convergence, High Availability, Low Latency, Conflict Resolution.
Benefits: Scalability, Performance, Fault Tolerance, Availability.
Advantages:
        1.	Highly suitable for large-scale, geo-distributed systems
        2.	Ensures uptime and responsiveness even when some nodes are unreachable
        3.	Improves throughput by avoiding bottlenecks of strict synchronization
        4.	Reduced latency compared to strong consistency systems
        5.	Works well for use cases where eventual correctness is acceptable, e.g., shopping carts, social media likes.
Disadvantages:
        1.	Stale Reads – Clients might read old or inconsistent data
        2.	Complex Conflict Resolution – Handling concurrent updates can be tricky
        3.	Not Suitable for All Use Cases – Banking or real-time systems need stronger consistency
        4.	Difficult Debugging – Bugs can arise due to timing or state mismatches across nodes
        5.	Increased Application Complexity – Developers may need to design around inconsistencies.
Azure Reservations:
        Azure Reservations allow you to pre-purchase Azure resources for a 1-year or 3-year term to receive significant discounts (up to 72%) compared to pay-as-you-        go pricing. You commit to using specific resource configurations (like a VM size in a region) for the duration of the term. 
Key Characteristics: Term Commitment, Scope, Region-specific, Exchangeable, Refundable, Billing Options.
Benefits of Azure Reservations: Significant Cost Savings, Predictable Billing, Performance Guarantee, Flexible Scope.
Limitations / Considerations: Less Flexibility, Unused Reservations Still Cost Money, Not Ideal for Short-Term or Bursty Workloads, Region-specific.
Best Use Cases: Long-running workloads, Predictable usage patterns, Enterprise apps with fixed infrastructure needs, Cost optimization for Dev/Test environments.
Azure Saving Plans:
Azure Savings Plans are flexible pricing models that allow you to save up to 65% on compute services by committing to a fixed hourly spend (e.g., $10/hour) for a 1-year or 3-year term. They apply automatically to eligible compute usage across various regions, VM sizes, and services.
Key Characteristics: Term Duration, Commitment Type, Scope, Flexibility, Applicable Services, Payment Options, Auto-application, Not Resource-Specific.
Benefits: Cost Savings, High Flexibility, Automatic Optimization, Predictable Spend, No Lock-In to Specific Resources.
Advantages: Very Flexible, Discounts Apply Automatically, Simple Budgeting, Ideal for Dynamic Workloads, Shared Across Resources.
Disadvantages: Fixed Hourly Commitment, No Savings Outside Compute, Not Ideal for Small Workloads, Limited to Certain Services, No Capacity Guarantee.
Best Use Cases: Dynamic or unpredictable workloads, Organizations using a mix of VM sizes/types, Developers using modern compute options.


Azure CLI :
Authentication & Account Info      Command	Purpose
az login - Login to your Azure account via CLI
az --version - Check the installed Azure CLI version
az account list	- List all Azure subscriptions associated with your account
az account list --output table - List subscriptions in table format for easier readability
az account set --subscription "<subscription-id>"	- Set the active subscription for your current session
Configuration Settings
Command	                        Purpose
az config set defaults.group="mamatha-rg"	- Set a default resource group so you don’t need to specify it each time
az config get defaults	- Show the current default configuration values
Resource Groups
Command	                       Purpose
az group list --help	- Get help/documentation for listing resource groups
az group list --query "[?location=='centralindia']"	- Filter resource groups located in Central India
az group list --query "[?name=='mamatha-rg']"	- Filter and find a specific resource group by name
az group list --query "[].name" --output tsv	- Get a simple list of all resource group names in plain text format
Virtual Machines
Command	                           Purpose
az vm list	- List all VMs in your subscription (empty list if none running)
az vm list -g Admin-Azure	- List VMs within the Admin-Azure resource group
az vm list -g Admin-Azure --query "[].name" --output tsv	- List VM names only
az vm list -g Admin-Azure --query "[].{Name:name}" --output tsv	- List VM names with custom field
az vm list -g Admin-Azure --query "[].{Name:name, ResourceGroup:resourceGroup}" --output tsv	- List VM names with their resource groups
Storage Accounts
Command	                           Purpose
az storage account list -g <resourcegroupname>	- List storage accounts in a specific resource group
env | grep -i storage
VM Sizes & SKUs
Command	                           Purpose
az vm list-skus --location centralindia --query "[?starts_with(name,'Standard_DS')]" --output table	- List available VM SKUs in Central India starting with Standard_DS (popular for Dev/Test workloads)

Authentication and Subscription Context using powershell :
    •	Logged in using Connect-AzAccount -UseDeviceAuthentication (because you're in a non-interactive session).
    •	Viewed your current context using Get-AzContext.
    •	Set your active subscription using:
            -	Set-AzContext -Subscription "bf7e75db-e819-49ca-b6d2-69c32a2353fe"
            -	Select-AzSubscription -SubscriptionId "bf7e75db-e819-49ca-b6d2-69c32a2353fe"
Working with Resource Groups
List all resource groups:
            -	Get-AzResourceGroup
Filter by location (e.g., Central India):
            -	Get-AzResourceGroup | Where-Object { $_.Location -eq "centralindia" }
Get a specific RG:
            -	Get-AzResourceGroup -Name "mamatha-rg"

Creating a Virtual Machine in Azure PowerShell:
Here’s a step-by-step example to create a VM inside the mamatha-rg resource group:
Step 1: Define parameters
        $rg = "mamatha-rg"
        $location = "centralindia"
        $vmName = "MamathaVM"
        $cred = Get-Credential
Step 2: Create a virtual network and subnet
        -	$subnetConfig = New-AzVirtualNetworkSubnetConfig -Name "mySubnet" -AddressPrefix "10.0.0.0/24"
        -	$vnet = New-AzVirtualNetwork -Name "myVnet" -ResourceGroupName $rg -Location $location -AddressPrefix "10.0.0.0/16" -Subnet $subnetConfig
Step 3: Create a public IP
        -	$pip = New-AzPublicIpAddress -Name "myPublicIP" -ResourceGroupName $rg -Location $location -AllocationMethod Dynamic
Step 4: Create a network interface
        -	$nic = New-AzNetworkInterface -Name "myNIC" -ResourceGroupName $rg -Location $location -SubnetId $vnet.Subnets[0].Id -PublicIpAddressId $pip.Id
Step 5: Configure VM and create it
        -	$vmConfig = New-AzVMConfig -VMName $vmName -VMSize "Standard_DS1_v2" |
        -	Set-AzVMOperatingSystem -Windows -ComputerName $vmName -Credential $cred -ProvisionVMAgent -EnableAutoUpdate |
        -	Set-AzVMSourceImage -PublisherName "MicrosoftWindowsServer" -Offer "WindowsServer" -Skus "2019-Datacenter" -Version "latest" |
        -	Add-AzVMNetworkInterface -Id $nic.Id
        -	New-AzVM -ResourceGroupName $rg -Location $location -VM $vmConfig
To remove everything at once, including:
        •	Virtual Machines
        •	Storage Accounts
        •	Network Security Groups
        •	All other resources
Just run this single PowerShell command:
        -	Remove-AzResourceGroup -Name "mamatha-rg" -Force

Roles define a set of permissions that can be assigned to users, groups, service principals, or managed identities to control access to Azure resources.
Roles
--identity
--users
--group
--service principles

RBAC Scope Levels or Azure hierarchy :
Management Groups → Organize multiple subscriptions, apply policies and access control.
Subscriptions → Billing boundaries; where resources are created and billed.
Resource Groups → Logical containers to group related resources together.
Resources → Actual Azure services like VMs, Storage accounts, Databases, etc.

26-04-2025:
Azure Functions App:
    An Azure Function is a serverless compute service that allows you to run event-driven code without managing infrastructure. It's useful for small tasks like processing data, running background jobs, responding to HTTP requests, or triggering workflows.
Steps to Create Azure Function for Automation:
1. Create an Azure Function App:
        - Go to the Azure Portal.
        - In the left menu, select Create a resource > Compute > Function App.
        - Fill in the required details (name, resource group, region, and runtime stack).
        - Click 'Review + Create' and then Create.
2. Create a Function Inside the Function App:
        - Once the Function App is created, navigate to it.
        - Under Functions, select + Add to create a new function.
        - Choose a template (e.g., HTTP trigger, Timer trigger, etc.) depending on your use case.
3. Write the Automation Code:
    For example, if you want to trigger a function on a schedule (cron-like), use a Timer Trigger.
    Define your function logic to automate tasks (e.g., interacting with Azure resources, processing data, etc.).
4. Deploy the Function:
    After writing your function code, click Deploy or test it using the built-in editor in the portal.
5. Configure Triggers:
    You can set your function to be triggered by HTTP requests, events, timed schedules, or other Azure services.
Azure Automation:
    Azure Automation is a cloud service that allows you to automate manual, long-running tasks such as patch management, VM configuration, and operational tasks. It leverages runbooks, which are collections of automation scripts.
Steps to Create Automation Using Azure Automation:
1.Create an Azure Automation Account:
    Go to the Azure Portal.
    Select Create a resource > IT & Management Tools > Automation.
    Provide a name, resource group, and region, and then click Create.
2.Create a Runbook in Automation:
    Once the Automation Account is created, navigate to it.
    Under the Process Automation section, select Runbooks.
    Click + Create a runbook.
    Choose a Runbook type (PowerShell, Python, etc.).
    Write your automation script (e.g., PowerShell script to start/stop VMs, scale services, etc.). Example of PowerShell to start a VM:
3.Test the Runbook:
    After creating the runbook, you can test it by clicking Start to ensure the automation works correctly.
4.Publish the Runbook:
    Once your script works as expected, publish it to make it available for scheduling or triggers.
5.Schedule the Runbook:
    To run the automation task on a schedule, go to the Runbook and select Link to Schedule.
    Create a new schedule with a cron expression (e.g., once a day, once an hour) and link it to your runbook.

28-04-2025
Infrastructure as Code (IaC) :
        IaC is the process of managing and provisioning computing infrastructure (servers, databases, networking, etc.) through machine-readable definition files, rather than physical hardware configuration or interactive configuration tools.

Popular IaC Tools :
Tool	              Type	                                                Description
Terraform	       Declarative            	                            Manages cloud infrastructure (multi-cloud support).
Ansible	           Imperative (also declarative with playbooks)	        Configuration management and automation.
CloudFormation	   Declarative	                                        AWS-native IaC service.
Pulumi	           Declarative/Imperative	                            Uses general-purpose languages (Python, Go, etc.).
Chef/Puppet	       Imperative/Declarative	                            Configuration management with strong DSLs.

Benefits of IaC :
Speed & Efficiency: Automate infrastructure provisioning in minutes.
Consistency: Reduce human error by reusing tested code.
Scalability: Easily replicate environments (e.g., staging, prod).
Versioning: Treat infrastructure like application code (Git, CI/CD).
Cost Efficiency: Remove unused resources with automation.
IaC Workflow :
Write infrastructure code.
Plan: Preview changes (terraform plan).
Apply: Deploy changes (terraform apply).
Monitor: Ensure infrastructure is healthy.
Destroy (optional): Remove infrastructure (terraform destroy).
Challenges :
State Management: Tools like Terraform require a state file; must be managed securely.
Drift Detection: Manual changes can cause configuration drift.
Security: Misconfigured scripts can expose critical data or cost resources.
IaC mainly has three categories:
1. Infrastructure Provisioning Tools :
        Infrastructure Provisioning Tools are software tools used to automatically create, configure, and manage IT infrastructure such as virtual machines, networks, storage, databases, and more—using code instead of manual processes.
Terraform – Open-source, multi-cloud support, uses HCL, declarative syntax.
AWS CloudFormation – AWS-native, declarative YAML/JSON templates.
Azure Bicep / ARM Templates – Azure-native, Bicep is a simpler DSL for ARM.
Google Cloud Deployment Manager – GCP-native, uses YAML or Python/Jinja2.
Pulumi – Multi-cloud, supports real programming languages (Python, Go, etc.).
Crossplane – Kubernetes-native, manages cloud infra via CRDs.
OpenStack Heat – Orchestration tool for OpenStack environments.
2. Configuration Management Tools :
        Configuration Management Tools are software tools that automate the setup, configuration, and ongoing management of servers and applications after the infrastructure is provisioned.
Ansible – Agentless, uses SSH, written in YAML (Playbooks), easy to learn and use, ideal for automation and configuration tasks.
Puppet – Agent-based, declarative DSL, suited for large-scale infrastructure, follows a client-server model.
Chef – Agent-based, uses Ruby DSL, great for complex workflows, follows client-server or solo mode.
SaltStack (Salt) – Can be agentless or agent-based, uses YAML (SLS files), fast and scalable, supports event-driven automation.
CFEngine – Lightweight, secure, agent-based, suitable for massive-scale infrastructures, one of the oldest tools in this space.
3. Server Templating Tools :
        Server Templating tools are used to automatically create and configure server environments or machine images in a consistent, repeatable manner.
Packer – Creates machine images automatically for different platforms from a single configuration.
Vagrant – Manages and sets up virtual machines, often used for development environments.
Dockerfile – Defines how to build a Docker container with the required software and settings.
Kickstart – Automates the installation and setup of Red Hat-based Linux systems.
Preseed – Automates the installation and setup of Debian/Ubuntu Linux systems.
Cloud-Init – Configures cloud instances automatically when they first start on platforms like AWS, Azure, or GCP.

What is Terraform :
        -Terraform is an open-source Infrastructure as Code (IaC) tool created by HashiCorp.
        -It allows you to define and provision infrastructure using a high-level configuration language (HCL - HashiCorp Configuration Language).
        -Multi-cloud support: Terraform can manage infrastructure across multiple cloud providers (AWS, Azure, GCP, etc.), as well as on-premise resources.
Key Concepts in Terraform :
1. Provider : 
        A provider in Terraform is responsible for managing API interactions with a specific platform (Azure in this case). It tells Terraform how to talk to Azure services.
Example (Azure Provider):
provider "azurerm" {
  features {}
}
2. Resource :
        A resource defines a piece of infrastructure you want to manage. In Azure, this could be a virtual machine, resource group, storage account, etc.
Example (Azure Resource Group):
resource "azurerm_resource_group" "example" {
  name     = "example-resources"
  location = "East US"
}
3. Module :
        Modules group resources into reusable blocks. You can use public modules or create your own to keep code clean and reusable.
Example (Using a Virtual Network Module):
module "vnet" {
  source              = "Azure/vnet/azurerm"
  resource_group_name = "example-resources"
  address_space       = ["10.0.0.0/16"]
}
4. State :
        Terraform tracks all created resources in a state file called terraform.tfstate. This file is critical for knowing what exists and what needs to be changed. Remote state is recommended in teams (e.g., use Azure Storage Account to store the state).
5. Plan :
        Terraform plan shows what Terraform will do: create, change, or destroy. This helps you verify before making actual changes.

Command: terraform plan
6. Apply :
        Terraform apply executes the plan and makes real changes in Azure. It provisions or updates Azure resources as defined in your .tf files.
Command: terraform apply
7. Destroy: 
        Terraform destroy removes all infrastructure created by Terraform in Azure.
Command: terraform destroy

Terraform Workflow :
- Write Configuration: You write configuration files (using .tf extension) to define your infrastructure.
- Initialize: Run terraform init to initialize Terraform and download the necessary provider plugins.
- Plan: Use terraform plan to preview the changes Terraform will make.
- Apply: Run terraform apply to apply the changes and provision the infrastructure.
- Destroy: Run terraform destroy to tear down and clean up resources.

Basic Commands :
terraform init: Initializes the Terraform working directory, downloading required providers and modules.
terraform validate: Validates your configuration files for syntax or logical errors.
terraform fmt: Formats your configuration files to follow best practices and style guides.
terraform output: Displays output variables defined in your configuration.

Best Practices in Terraform :
Version control: Store .tf files in version control systems (like Git) to track changes and collaborate.
Remote state: Use remote state storage to share the state file across teams and provide a single source of truth.
Modularize: Use modules to encapsulate common configurations and reduce code duplication.
Variables: Use input variables to make your configurations flexible and reusable.

Terraform Benefits :
Multi-cloud: Manage infrastructure across multiple cloud providers with a single configuration.
Version-controlled infrastructure: Store infrastructure definitions in source control for auditability and collaboration.
Reusable modules: Create reusable, modular code for commonly used resources.
Declarative configuration: You define what you want, and Terraform handles the how.

Common Challenges in Terraform :
State management: Handling Terraform state files can be tricky, especially in teams. It's essential to use remote state backends.
Drift: Changes made outside of Terraform (like manual changes in the console) may cause drift, where the actual state differs from the desired state.

What Is the Terraform Lockfile?
The .terraform.lock.hcl file is a dependency lockfile that ensures consistent versions of provider plugins (e.g., Kubernetes, Docker, Helm, etc.) are used across all environments, especially in team or CI/CD setups.

Why It's Needed :
Consistency: Ensures that Terraform always uses the same provider versions regardless of where or when it's run.
Security & Integrity: Stores checksums for provider binaries to ensure they haven't been tampered with.
Predictability: Avoids unexpected behavior from provider version changes when re-running Terraform code later.

How It Works:
1. When you run terraform init, Terraform will fetch the provider plugins and create the .terraform.lock.hcl file.
2. The lockfile contains metadata about the provider’s version, including checksums for verification to ensure no tampering or corruption of the provider's binaries.
3. If you change the provider version or update dependencies, Terraform will update the lockfile with the new provider versions.

What is .tf File in Terraform?
•	.tf files are Terraform configuration files where you write the instructions for infrastructure.
•	These files describe what you want (servers, databases, networking, etc.).

Terraform Advantages :
1. Automation – Automates infrastructure provisioning and eliminates manual setup.
2. Continuity – Ensures consistent and incremental infrastructure changes over time.
3. Speed – Rapid deployment using dependency graph and parallel resource creation.
4. Reusability – Promotes reusable modules to avoid repetition and standardize code.
5. Consistency – Guarantees identical infrastructure across environments and teams.
6. Version Control – Enables tracking, collaboration, and rollback via Git integration.
7. Security – Secures infrastructure with secrets management and encrypted state files.

State Management in Terraform :
        Terraform keeps track of the real-world infrastructure in a file called terraform.tfstate.

Key Points:
        Stores metadata about resources.
        Allows Terraform to detect drift and plan changes.
        Can be stored remotely (S3, Azure Storage, Terraform Cloud) for team collaboration.
Benefits:
        Centralized source of truth.
        Supports terraform plan to preview changes before applying.

What is Policy as a Code?
Policy as Code is the practice of writing and managing governance, compliance, and security policies in code form using high-level, declarative languages. These policies are automatically enforced during infrastructure provisioning.
Instead of manually reviewing security or compliance rules, PaC embeds those rules directly into your DevOps pipelines, ensuring they are checked consistently and automatically.

Why Policy as a Code?
Manual policy enforcement is:
Error-prone
Slow
Inconsistent across teams
PaC solves these problems by:
Automating policy checks
Preventing violations before deployment
Making policies version-controlled, testable, and auditable
Where is Policy as Code Used?
PaC is used in:
Terraform pipelines – Enforce rules before applying infrastructure.
CI/CD pipelines – Block deployments if non-compliant.
Cloud platforms:
Azure → Azure Policy
AWS → SCPs, Config Rules
GCP → Organization Policies
Kubernetes → OPA + Gatekeeper for validating manifests
Benefits of Policy as a Code:
    Automation, Consistency, Speed and Scalability, Security and Compliance, Auditability, Testability, Flexibility.

CI/CD in Terraform 
CI/CD (Continuous Integration and Continuous Deployment) in Terraform refers to automating the process of planning, validating, and applying infrastructure changes using Terraform within a CI/CD pipeline.
What is CI/CD in Terraform?
CI (Continuous Integration): Every time infrastructure code (like .tf files) is pushed to a Git repo, the pipeline automatically:
Validates syntax (terraform validate)
Checks formatting (terraform fmt)
Runs security scans or policy checks (e.g., with OPA or Sentinel)
Generates an execution plan (terraform plan)
CD (Continuous Deployment/Delivery): If the plan looks good (and optionally approved), it:
Applies changes automatically (terraform apply)
Manages infrastructure updates safely and consistently
Common CI/CD Tools Used with Terraform
        GitHub Actions, GitLab CI, Azure DevOps, Jenkins, CircleCI, Bitbucket Pipelines
Typical Terraform CI/CD Pipeline Stages:
        Terraform Init – Initializes the working directory.
        Terraform Validate – Validates the configuration syntax.
        Terraform Fmt – Ensures consistent formatting.
        Terraform Plan – Creates an execution plan showing what will change.
        Policy Check – Optional (Sentinel/OPA) policy validation.
        Manual Approval – Optional step for review.
        Terraform Apply – Provisions or updates infrastructure.
Benefits :
        Faster and safer infrastructure changes
        Reduced manual errors
        Full version control and traceability
        Easier collaboration among teams
Semantic Versioning (SemVer) is a versioning system for software, typically formatted as MAJOR.MINOR.PATCH.
        MAJOR (2): Indicates backward-incompatible changes. Updating may require modifying your code.
        MINOR (40): Adds new features in a backward-compatible way. You can use the new features, but existing code remains unaffected.
        PATCH (0): Fixes bugs or provides minor improvements without changing functionality. Safe to upgrade.
For example, 2.40.0:
        The MAJOR version is 2, meaning some breaking changes might have occurred.
        The MINOR version is 40, meaning new features were added.
        The PATCH version is 0, meaning no bug fixes have been released yet.
When specifying version constraints in Terraform, you can control what updates to allow. For example:
        ~> 2.40.0 allows 2.40.x but not 2.41.0.
        >= 2.40.0, < 3.0.0 allows all versions up to 3.0.0 but not including it.
This system helps maintain compatibility while providing new features and bug fixes over time.

why storing Terraform state remotely is important:
    Collaboration: Enables multiple team members to work with the same state file.
    State Locking: Prevents concurrent updates and conflicts using locks (e.g., in S3 with DynamoDB).
    Data Integrity: Ensures high availability and durability of state files.
    Backup and Recovery: Easier to back up and recover state files when stored remotely.
    Version Control: Maintains a version history of the state, allowing rollback.
    Security: Enables encryption and fine-grained access control for sensitive data.
    Centralized Management: Organizes state files for different environments and resources.
    Terraform Cloud/Enterprise Features: Provides additional collaboration, policy enforcement, and access control.

Step-by-Step: Remote State Storage in Azure
1. Create Azure Storage Resources
Run these commands in your terminal:
# Create a resource group
az group create --name tfstate-rg --location southindia
# Create a storage account (name must be globally unique)
az storage account create \
  --name mamathastatestorage \
  --resource-group tfstate-rg \
  --location southindia \
  --sku Standard_LRS
# Create a blob container to store the state file
az storage container create \
  --name tfstate \
  --account-name mamathastatestorage
2. Get the Storage Account Key
Run the following command to retrieve the storage account key:
az storage account keys list \
  --resource-group tfstate-rg \
  --account-name mamathastatestorage
Copy one of the keys from the output.

3. Configure Backend in Your Terraform Code
Create a backend.tf file (or include this block inside your main.tf):
terraform {
  backend "azurerm" {
    resource_group_name   = "tfstate-rg"
    storage_account_name  = "mamathastatestorage"
    container_name        = "tfstate"
    key                   = "terraform.tfstate"  # This is the blob name (state file)
  }
}
4. Set Access Key as Environment Variable
Before initializing Terraform, export the storage account key:
export ARM_ACCESS_KEY="your-access-key-here"
Alternatively, you can use a Terraform-managed service principal with environment variables like ARM_CLIENT_ID, ARM_CLIENT_SECRET, etc.
5. Initialize Terraform
Run the following command to initialize Terraform:
terraform init
You'll see a prompt asking if you want to migrate the existing local state to the new backend — answer yes.
This setup ensures that your Terraform state is stored securely and is easily accessible for collaboration across teams.

Azure provides different types of storage accounts :
1. Blob Storage:
Purpose: Used to store unstructured data, such as text, images, videos, backups, and logs.
Key Feature: Data is stored as blobs (binary large objects) in containers.
Use Cases: Storing large files like media files, backups, and data lakes.
Blob Types:
Block Blobs: Ideal for storing text or binary data.
Append Blobs: Used for logging.
Page Blobs: Used for Azure VMs' OS and data disks.

2. File Storage:
Purpose: Provides managed file shares that can be accessed via SMB (Server Message Block) protocol.
Key Feature: Ideal for applications that need shared file storage, accessible from multiple VMs or systems.
Use Cases: Lift-and-shift applications that need shared access to files.
Access: Can be accessed by both Windows and Linux systems.

3. Table Storage (NoSQL):
Purpose: A NoSQL key-value store for structured data that doesn't require a relational database.
Key Feature: Stores data in tables with rows and columns, but without fixed schemas (flexible and scalable).
Use Cases: Storing application data, session state, and metadata in a schema-less format.
Access: Suitable for large-scale, low-latency applications that need a simple NoSQL data store.
Partition Key: The Partition Key is used to group related rows for efficient data distribution and retrieval in a table (ensures data is stored in the same partition).
Row Key: The Row Key uniquely identifies each record within a partition, ensuring the uniqueness of rows within the partition.

4. Queue Storage:
Purpose: Provides message queuing for communication between different parts of an application.
Key Feature: Stores messages that can be accessed by different applications or services.
Use Cases: Decoupling components, handling background tasks, and processing large amounts of data asynchronously.
Access: Messages can be retrieved from queues using the REST API or SDKs.

Create a Container through Azure Portal (Storage Browser)
1. Create a Storage Account:
Log in to the Azure portal and create a storage account using the following steps:
Go to the storage account service.
Click Create, choose the required settings (like Name as mamathasa1, Location as South India, etc.), and click Create.
2. Go to Storage Browser:
After the storage account is created, go to the Storage Browser by selecting your storage account from the Azure portal.
3. Click on Containers and Add the Container:
In the Storage Browser, click on Containers.
Click + Container to create a new container.
Enter the name as mamatha and set the access level to Private (or choose based on your needs).
Click Create.
4. Upload the File and Generate SAS:
After creating the container, click on it to open it.
Click Upload, select the file to upload, and click Upload.
After the file is uploaded, click on the file, then click Generate SAS to create a Shared Access Signature (SAS).
Copy the Blob URL from the SAS generation section.
Open the copied Blob URL in your browser to access the file.
--------------------------------------------------------------
Create Storage Account (Container) through Terraform:
resource "azurerm_resource_group" "example" {
  name     = "mamatha-rg5"
  location = "southindia"
}

resource "azurerm_storage_account" "example" {
  name                     = "mamathasa1"
  resource_group_name      = azurerm_resource_group.example.name
  location                 = azurerm_resource_group.example.location
  account_tier             = "Standard"
  account_replication_type = "LRS"
}

resource "azurerm_storage_container" "example" {
  name                   = "mamatha"
  storage_account_name   = azurerm_storage_account.example.name
  container_access_type  = "private"
}

terraform {
  required_providers {
    azurerm = {
      source = "hashicorp/azurerm"
      version = "2.40.0"
    }
  }
}

provider "azurerm" {
  features {}
}
This Terraform configuration creates:
A resource group (mamatha-rg5).
A storage account (mamathasa1).
A container (mamatha) within the storage account.
After running terraform apply, the container will be created. we can then upload a file manually and generate a SAS URL to access it.
--------------------------------------------------------------------------------
Mount Storage Account (File Share) into a VM :
        Create Storage Account: Create a storage account in Azure (via the portal or Terraform).
        Go to Storage Browser: Navigate to Storage Browser and select File Shares. Click + File Share, name it, and create it.
        Get Mount Script: In the File Share section, click Connect to get the Linux mount script.
        Create VM: Create a VM in Azure, set up SSH access, and generate an SSH key (ssh-keygen -t rsa).
        SSH into VM: Access the VM using SSH (ssh -i path_to_key user@public_ip).
        Mount File Share: Follow the provided Linux mount script to mount the file share on the VM.
        Create Folder: Switch to superuser (sudo su), run the mount command, and create a folder. The folder will appear in the Azure portal under the File Share.

Database Concepts:
Pages: A database page is a fixed-size block of data stored in memory or on disk. It is the smallest unit of data retrieval in a database.
Key-Value Pair: A key-value pair stores data as a unique key and its corresponding value, commonly used in NoSQL databases for fast retrieval.
Documentation: Database documentation refers to the information about the database schema, relationships, queries, and how data is stored and accessed.
Wide Column Database (NoSQL): A Wide Column Database stores data in columns rather than rows, providing better performance and flexibility for read and write operations on large datasets (e.g., Cassandra).

Microservice Communication:
Synchronous Communication: In synchronous communication, services interact in real-time, where the client waits for a response. A load balancer is needed to distribute requests and ensure high availability.
Asynchronous Communication:
Queue-Based: In this setup, the client sends a message to a broker (e.g., RabbitMQ, Kafka). The client or service picks the message when ready. It does not require a load balancer, as it is decoupled.
Public Communication: This could involve services sending and receiving messages via a public API, again decoupling them but relying on mechanisms like API gateways instead of load balancers.
--------------------------------------------------------------------------------------------------------------------------------------
VMScaleset Full Step-by-Step: Apache with VM, VM Image, VMSS, Load Balancer
🔹 Step 1: Create a VM and Connect via SSH
Go to Azure Portal → Search for "Virtual Machines" → Click “Create”
Fill in: Resource Group: mamatharg1, VM Name: apache-vm, Region: East US (or any choice), Image: Ubuntu 22.04 LTS, Authentication: SSH public key, Username: azureuser
Click Next through the tabs and Create
Once created, go to the Overview tab and get the public IP

Connect via SSH:
ssh -i ~/.ssh/id_rsa azureuser@<public-ip>
🔹 Step 2: Install Apache and Open HTTP Port
On the VM (via SSH):
sudo apt update
sudo apt install -y apache2
sudo systemctl start apache2
sudo systemctl enable apache2
In Azure Portal:
Go to the VM > Networking
Click "Add inbound port rule"
Add: Port: 80, Protocol: TCP, Action: Allow, Name: Allow-HTTP
✅ Now test by opening the VM's public IP in a browser. You should see the Apache default page.
🔹 Step 3: Create VNet with Public and Private Subnets
Go to Virtual Networks → Click "Create"
Fill:
Name: apache-vnet, Region: Same as VM, Resource Group: mamatharg1, Under IP Addressing
define:
Address Space: 10.0.0.0/16
Subnet 1 (public-subnet): 10.0.1.0/24
Subnet 2 (private-subnet): 10.0.2.0/24
Review and Create
🔹 Step 4: Capture an Image of the VM
Note: Capturing an image deallocates (stops) the VM.
Go to your VM → Click "Capture" in the top menu
Fill: Name: apache-image, Resource Group: mamatharg1
Select Automatically delete this VM after creating image (if desired)
Click Review + Create → Then Create
🔹 Step 5: Create a VM Scale Set (VMSS) from the Image
Go to Virtual Machine Scale Sets → Click "Create"
Fill: Name: apache-vmss, Resource Group: mamatharg1, Image: Select the custom image you captured, Region: Same, Instance count: 2 or more, Authentication: Same SSH key
Load Balancing tab:
Select Create a new load balancer
Choose Public IP
Backend Pool: myBackEndPool
Under Networking, choose:
VNet: apache-vnet
Subnet: public-subnet
Click Review + Create → Then Create
🔹 Step 6: Access Apache via Load Balancer Public IP
Once deployed, go to:
Load Balancer > Frontend IP Configuration
Copy the public IP
Open the IP in your browser:
http://<load-balancer-ip>
✅ You should now see the Apache page served by one of the VMSS instances!
--------------------------------------------------------------------------------------------------------------------------------

Deploying an Azure Linux Virtual Machine Scale Set (VMSS) with Load Balancer using Terraform:
provider "azurerm" {
  features {}
  subscription_id = "bf7e75db-e819-49ca-b6d2-69c32a2353fe"
}
 
# Existing Resource Group
resource "azurerm_resource_group" "rg" {
  name = "mamatha-rg"
  location = "eastus"
}
 
# Virtual Network and Subnets
resource "azurerm_virtual_network" "vnet" {
  name                = "mamatha-vnet"
  address_space       = ["10.55.0.0/16"]
  location            = resource.azurerm_resource_group.rg.location
  resource_group_name = resource.azurerm_resource_group.rg.name
}
 
resource "azurerm_subnet" "public_subnet" {
  name                 = "public"
  resource_group_name  = resource.azurerm_resource_group.rg.name
  virtual_network_name = azurerm_virtual_network.vnet.name
  address_prefixes     = ["10.55.1.0/24"]
}
 
resource "azurerm_subnet" "private_subnet" {
  name                 = "private"
  resource_group_name  = resource.azurerm_resource_group.rg.name
  virtual_network_name = azurerm_virtual_network.vnet.name
  address_prefixes     = ["10.55.2.0/24"]
}
 
# Load Balancer and Public IP
resource "azurerm_public_ip" "lb_public_ip" {
  name                = "mamatha-public-ip"
  location            = resource.azurerm_resource_group.rg.location
  resource_group_name = resource.azurerm_resource_group.rg.name
  allocation_method   = "Static"
  sku                 = "Standard"
}
 
resource "azurerm_lb" "lb" {
  name                = "mamatha-lb"
  location            = resource.azurerm_resource_group.rg.location
  resource_group_name = resource.azurerm_resource_group.rg.name
  sku                 = "Standard"
 
  frontend_ip_configuration {
    name                 = "PublicFrontend"
    public_ip_address_id = azurerm_public_ip.lb_public_ip.id
  }
}
 
resource "azurerm_lb_backend_address_pool" "backend_pool" {
  name            = "mamatha-backend-pool"
  loadbalancer_id = azurerm_lb.lb.id
}
 
resource "azurerm_lb_probe" "http_probe" {
  name            = "http-probe"
  loadbalancer_id = azurerm_lb.lb.id
  protocol        = "Tcp"
  port            = 80
}
 
# Corrected `azurerm_lb_rule` (no `resource_group_name`, and using `backend_address_pool_ids`)
resource "azurerm_lb_rule" "http_rule" {
  name                           = "http-rule"
  loadbalancer_id                = azurerm_lb.lb.id
  protocol                       = "Tcp"
  frontend_port                  = 80
  backend_port                   = 80
  frontend_ip_configuration_name = "PublicFrontend"
  backend_address_pool_ids       = [azurerm_lb_backend_address_pool.backend_pool.id]
  probe_id                       = azurerm_lb_probe.http_probe.id
}
 
# NSG for VMSS Subnet
resource "azurerm_network_security_group" "web_nsg" {
  name                = "mamatha-nsg"
  location            = resource.azurerm_resource_group.rg.location
  resource_group_name = resource.azurerm_resource_group.rg.name
 
  security_rule {
    name                       = "AllowHTTP"
    priority                   = 100
    direction                  = "Inbound"
    access                     = "Allow"
    protocol                   = "Tcp"
    source_port_range          = "*"
    destination_port_range     = "80"
    source_address_prefix      = "*"
    destination_address_prefix = "*"
  }
}
 
resource "azurerm_subnet_network_security_group_association" "nsg_assoc" {
  subnet_id                 = azurerm_subnet.private_subnet.id
  network_security_group_id = azurerm_network_security_group.web_nsg.id
}
 
# VM Scale Set
resource "azurerm_linux_virtual_machine_scale_set" "vmss" {
  name                             = "mamatha-vmss"
  resource_group_name              = resource.azurerm_resource_group.rg.name
  location                         = resource.azurerm_resource_group.rg.location
  sku                              = "Standard_B1s"
  instances                        = 3
  admin_username                   = "mamatha"
  admin_password                   = "qwerty@1234"  # Replace in real deployments
  disable_password_authentication = false
  source_image_id                  = "/subscriptions/bf7e75db-e819-49ca-b6d2-69c32a2353fe/resourceGroups/mamatha-rg/providers/Microsoft.Compute/galleries/mamathagallery/images/mamatha-image/versions/0.0.1"
  upgrade_mode                     = "Manual"
  # security_type = "TrustedLaunch"
  secure_boot_enabled = true

custom_data = base64encode(<<EOF
#!/bin/bash
apt-get update
apt-get install -y apache2
systemctl start apache2
systemctl enable apache2
echo "<h1>Hello from Apache on VMSS!</h1>" > /var/www/html/index.html
EOF
  )

  network_interface {
    name    = "vmss-nic"
    primary = true
 
    ip_configuration {
      name                                   = "internal"
      primary                                = true
      subnet_id                              = azurerm_subnet.private_subnet.id
      load_balancer_backend_address_pool_ids = [azurerm_lb_backend_address_pool.backend_pool.id]
    }
  }
 
  os_disk {
    caching              = "ReadWrite"
    storage_account_type = "Standard_LRS"
  }
}
 
# Output Public IP of Load Balancer
output "load_balancer_ip" {
  value = azurerm_public_ip.lb_public_ip.ip_address
}
-------------------------------------------------------------------
Meta Arguments in terraform: 
In Terraform, meta-arguments are special arguments you can use inside resource, module, or data block configurations to control how the resource is managed — not the resource itself. They don’t configure the actual infrastructure but influence how Terraform behaves when creating, updating, or destroying the resource.
1. count
Used to create multiple instances of a resource by specifying a number.
2. for_each
Allows iteration over a map or set to create multiple uniquely keyed resources.
3. provider
Specifies which provider configuration to use, especially useful in multi-account or multi-region deployments.
4. depends_on
Explicitly defines dependencies between resources when Terraform cannot infer them automatically.
5. lifecycle
Manages how resources are created, updated, or destroyed, with options like prevent_destroy, create_before_destroy, and ignore_changes.

Health Checks in Kubernetes :
In Kubernetes, health checks (also called probes) are used to monitor the status of application containers. There are three main types:
1. Liveness Probe :
Purpose: To check if the application is alive (i.e., still running properly).
If the liveness probe fails, Kubernetes restarts the container.
Useful when your application might hang or enter a non-recoverable state.
Helps automatically recover from crashes or deadlocks.
2. Readiness Probe :
Purpose: To check if the application is ready to serve traffic.
If the readiness probe fails, the container is removed from the Service endpoints.
It prevents traffic from being routed to a container that’s not ready.
Useful during startup, maintenance, or when the app is temporarily not available.
3. Startup Probe :
Purpose: To check if the application has started successfully.
Used for slow-starting applications.
If the startup probe fails repeatedly, the container is killed.
Once this probe passes, liveness and readiness probes take over.
--------------------------------------------------------------
Azure Table Storage + Logic App:
    -Create Table in Storage Browser.
    -Create Logic App → Go to Logic App Designer.
    -Add trigger (e.g., HTTP request).
    -Add Insert Entity action for Table Storage.
    -Fill in PartitionKey, RowKey, and custom fields.
    -Save & Run the Logic App.
    -Go to Table in Storage Browser to see inserted data.
Azure Queue Storage + Logic App :
    -Create Queue in Storage Browser.
    -Create Logic App → Go to Logic App Designer.
    -Add trigger (e.g., Recurrence or HTTP).
    -Add Put Message in Queue action.
    -Fill in queue name and message content.
    -Save & Run the Logic App.
    -Check the Queue in Storage Browser for messages.
--------------------------------------------------------------------
In Azure terraform learned about meta-args and the count function 
terraform {
  required_providers {
    azurerm = {
      source = "hashicorp/azurerm"
      version = "4.27.0"
    }
  }
}
provider "azurerm" {
  # Configuration options
    features{}
}
resource "azurerm_resource_group" "example" {
  name     = "mamatharg1${count.index+1}"
  location = "central india"
  count = 2
}
----------------------------------------------------------------------
Variables in Terraform :
In Terraform, variables are used to make configurations more dynamic and reusable. There are three main types of variables:
1. Input Variables (variable)
Purpose: Accept values from the user or calling module.
Defined using: variable blocks.
Usage: Allows passing data into modules or Terraform configurations.
Example:
variable "location" {
  type    = string
  default = "East US"
}
Used as:
location = var.location
Can be provided via .tfvars, environment variables, or CLI (-var flag).

2. Local Values (locals)
Purpose: Assign reusable expressions or calculated values.
Defined using: locals block.
Usage: Simplifies repeated or complex expressions.
Example:
locals {
  vm_name = "my-vm-${var.environment}"
}
Used as:
name = local.vm_name
Not passed in from outside — used internally in  configuration.

3. Output Values (output)
Purpose: Show values after a Terraform run or pass data between modules.
Defined using: output blocks.
Usage: Useful for displaying info like IP addresses, IDs, etc.
Example:
output "vm_ip" {
  value = azurerm_linux_virtual_machine.vm.private_ip_address
}
Outputs are displayed after terraform apply and can be used by other modules when called.



